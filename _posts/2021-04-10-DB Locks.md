---
layout: page
title: Database Lock Optimizations
tags: [Database]
excerpt_separator: <!--more-->
typora-root-url: ../
---

## Efficient Locking Techniques for Databases on Modern Hardware

### 0x00 åŸºæœ¬å†…å®¹

 è¿™ç¯‡paperæ˜¯å…³äºæ•°æ®åº“ä¸Šlockçš„ä¸€äº›ä¼˜åŒ–ï¼Œè¿™äº›å†…å®¹æ˜¯åœ¨Shore-MTä¸Šé¢åšçš„ï¼Œå¯èƒ½å’ŒShore-MTçš„å®ç°ä¹Ÿæœ‰ä¸€å®šçš„å…³ç³»ã€‚è¿™é‡Œè®¨è®ºäº†range lockingã€intent lockså’Œdeadlock detectionä»¥åŠearly lock releaseçš„ä¸€äº›ä¼˜åŒ–ã€‚

<img src="/assets/png/efflock-rangemode.png" style="zoom:80%;" />

Range lockingçš„ä¸€äº›ä¼˜åŒ–è®¨è®ºäº†ä¸€äº›èŒƒå›´é”çš„å†…å®¹ã€‚ä¸Šå›¾è¡¨ç¤ºäº†range lockçš„ä¸€äº›ç±»å‹ä»¥åŠå…¶ä¸åŒç±»å‹æ‰€ä¹‹é—´çš„äº’æ–¥å…³ç³»ã€‚å…¶ä¸­Nè¡¨ç¤ºnot lockï¼Œè€Œä¾‹å¦‚ â€˜SXâ€™ è¡¨ç¤ºâ€˜key shared, gap exclusiveâ€™ï¼Œå…¶å®ƒç±»ä¼¼ã€‚è¿™é‡Œçš„ä¸€ä¸ªä¼˜åŒ–æ˜¯modesåšå¾—å¾ˆç»†ï¼Œä¼˜åŒ–äº†ä¹‹å‰ä¸€äº›lockæ–¹æ³•æœ‰äº›æƒ…å†µæ²¡æœ‰è¶³å¤Ÿä¼˜åŒ–çš„æƒ…å†µï¼Œæ¯”å¦‚ç¼ºå°‘â€˜RangeS-Nâ€™ (N stands for â€˜not lockedâ€™)è¿™æ ·çš„æ¨¡å¼ã€‚è¿™ç§æ¨¡å¼åœ¨æœ‰[10, 20, 30]è¿™æ ·çš„è®°å½•ä¸­æŸ¥è¯¢`Select * From T Where T.a = 15æ—¶ï¼Œå¯ä»¥åœ¨10ä¸ŠåŠ ä¸€ä¸ªNS-mode (key free, gap shared)çš„é”ï¼Œè¿™æ ·keyåŠ çš„æ˜¯N lockï¼Œå³æ²¡æœ‰lockã€‚ç±»ä¼¼çš„ä¹‹å‰çš„æ–¹æ¡ˆä¹Ÿæ²¡æœ‰ â€˜RangeS-Xâ€™ å’Œâ€˜RangeX-Nâ€™ è¿™æ ·çš„æ¨¡å¼ã€‚åœ¨è¿™é‡Œï¼Œä¸€äº›æ“ä½œçš„åŠ é”çš„æ–¹å¼å¦‚ä¸‹ï¼š

* å¯¹äºç‚¹æŸ¥è¯¢/æ·»åŠ ã€‚ä»¥ä¸‹é¢çš„æŸ¥è¯¢ä¸ºä¾‹ï¼Œå…ˆæ‰¾æ‰“å¯¹åº”çš„leaf pageï¼Œè¿™ä¸ªæ—¶å€™æŒæœ‰leaf pageçš„S latchã€‚å¦‚æœåŒ¹é…åˆ°ä¸€ä¸ªkeyï¼Œåˆ™åŠ é”SN lockï¼Œå³keyä¸ºshared lockï¼Œè€Œgapä¸ºnot lockçš„é”ã€‚è¿™é‡Œè¦å¤„ç†åˆ©ç”¨ghostè®°å½•æ¥å¤„ç†deleteçš„æƒ…å†µã€‚è€Œå¯¹äºä¸å­˜åœ¨çš„ekyï¼Œæ ¹æ®æƒ…å†µåŠ é”NS lockã€‚

  ```
  Data: B: B-tree index, L: Lock table
  Input: key: Searched key
    leaf_page = B.Traverse(key); // hold S latch 
    slot = leaf page.Find(key);
    if slot.key == key then //Exact match
      L.Request-Lock(key, SN); 
      if slot is not ghost then
        return (slot.data);
      else
        return (Error: NOT-FOUND);
    else //Non-existent key
      if slot < 0 then //hits left boundary of the page
        L.Request-Lock(leaf page.low fence key, NS);
      else
        L.Request-Lock(slot.key, NS); 
      return (Error: NOT-FOUND);
  ```

  è¿™æ ·å¯¹äºè®°å½•çš„ç‚¹æ·»åŠ ä¹Ÿæ˜¯ä¸€æ ·ï¼Œå¯¹äºå­˜åœ¨keyçš„æƒ…å†µï¼Œæƒ³è¦åŠ ä¸€ä¸ªXNé”ï¼Œå³keyä¸ºXé”ï¼Œgaoä¸ºnot lockã€‚æ ¹æ®è®°å½•æ˜¯å¦ä¸ºghostä½œå‡ºåˆ†åˆ«çš„å¤„ç†ã€‚å¯¹äºkeyä¸å­˜åœ¨çš„æƒ…å†µï¼Œæ ¹æ®æƒ…å†µåŠ é”NXé”ã€‚ç„¶ååˆ›å»ºä¸€ä¸ªsys txnï¼ŒåŠ å…¥ä¸€ä¸ªghost keyå¹¶åŠ æ˜¯XNé”ï¼Œæœ€åæ·»åŠ æ•°æ®ã€‚

* å¦å¤–ä¸€ä¸ªå°±æ˜¯èŒƒå›´æŸ¥è¯¢çš„å¤„ç†ï¼Œå¯¹äºç±»ä¼¼`Select * From T Where T.a Between 15 And 25`è¿™æ ·çš„èŒƒå›´æŸ¥è¯¢ï¼Œæ ¹æ®å…¶æ˜¯å‡åºçš„è¿˜æ˜¯é™åºçš„ï¼Œæœ‰æ²¡æœ‰åŒ…æ‹¬èŒƒå›´è¾¹ç•Œçš„keyï¼ŒåŠ ä¸Šä¸åŒçš„lockã€‚è¿™é‡Œä¼šæœ‰ä¸€äº›å‡çº§åˆ°æ›´é«˜çš„é”æ¥é¿å…ä¸€äº›å¼€é”€ï¼Œå› ä¸ºä¸€èˆ¬çš„æ–¹å¼ä¸ºå…ˆåœ¨starting positionåŠ é€Ÿï¼Œç§»åŠ¨çš„æ—¶å€™å¯¹äºä¸‹é¢çš„keyä¹Ÿæƒ³è¦åŠ é€Ÿï¼Œæ¯”å¦‚åœ¨Aä½ç½®çš„æ—¶å€™å…ˆåœ¨AåŠ ä¸ŠSNçš„é”ï¼Œåé¢çš„keyå¯èƒ½åˆè¦åŠ é”ã€‚å¤šæ¬¡æ“ä½œå¯èƒ½å¸¦æ¥é¢å¤–çš„å¼€é”€ï¼Œè¿™é‡Œç›´æ¥å°±ä½¿ç”¨Sç±»å‹çš„ã€‚

  ```
  For example, an ascending cursor starting from exact-match on A could take only an â€˜SNâ€™ lock on A and then upgrade to an â€˜Sâ€™ lock on the same key when moving on to the next key. However, this doubles the overhead to access the lock table. Instead, the storage manager takes the two locks at the same time to reduce the overhead at the cost of slightly lower concurrency, 
  ```

å¦å¤–çš„ä¸€ä¸ªå†…å®¹æ˜¯å…³äºintent locksã€‚è¿™é‡Œè®¨è®ºäº†å¦‚ä½•é™ä½åœ¨æ„å‘é”ä¸Šé¢çš„ä¸€äº›å†²çªå¼€é”€ã€‚åœ¨è¿™é‡Œæå‡ºäº†ä¸€ä¸ªLightweight Intent Lock (LIL)çš„æ–¹å¼ï¼Œåœ¨LILä¸­ï¼Œé™¤äº†ä¸€ä¸ªglobal lock table (GLT)ï¼Œæ¯ä¸ªtxnä¼šç»´æŠ¤ä¸€ä¸ª private lock ta- ble (PLT)ã€‚åœ¨PLTä¸­ä¼šè®°å½•äº‹åŠ¡çš„intent locksã€‚ä¸€ä¸ªtxnè¦è·å–ä¸€ä¸ªintent lockçš„æ—¶å€™ï¼Œå…ˆæŸ¥è¯¢è‡ªå·±çš„PLTï¼Œå¦‚æœå­˜åœ¨åˆ™å·²ç»è·å–äº†ã€‚å¦‚æœæ²¡æœ‰ï¼Œåˆ™æŸ¥è¯¢GLTï¼Œå¹¶å¢åŠ å¯¹åº”lockæ¨¡å¼ä¸­çš„counterçš„è®¡æ•°(The GLT records the count of granted lock requests for each lock mode (S/X/IS/IX).)ã€‚å…¨å±€çš„æ“ä½œéƒ½æ˜¯å¾ˆç®€å•çš„ã€‚å¦‚æœé”æ²¡æœ‰ç«‹å³è·å–åˆ°ï¼Œè¿™é‡Œä¼šç”¨åˆ°mutexã€‚åœ¨é”è¢«é‡Šæ”¾çš„æ—¶å€™ï¼Œè¦å‡å°‘counterçš„è®¡æ•°ã€‚

```
Algorithm 3: Lightweight intent lock: Request-lock. 
Data: G: Global lock table, P : Private lock table
Input: i: Index to lock, m: lock mode (IS/IX/S/X) 
if P [i].granted[m] is already true  then
  return;
while Until timeout do
  begin Critical-Section{G[i].spinlock} 
    if m can be granted(âˆ—) in G[i] then
      ++G[i].granted counts[m]; 
      P[i].granted[m] = true; 
      return;
    if m âˆˆ {S,X} then
      Leave a flag to announce absolute locks(âˆ—);
    base_version = G[i].version;
  cur_version = base_version;
  while cur_version == base_version do
    Conditional-Wait(G[i].mutex, 1 millisec); 
    cur_ersion = G[i].version;
```

### 0x01 Deadlock and EarlyLockRelease

 è¿™é‡Œè¿˜è®¨è®ºäº†Deadlock çš„ä¸€äº›ä¼˜åŒ–ã€‚è¿™é‡Œä½¿ç”¨çš„Deadlockæ£€æµ‹çš„åŸºæœ¬æ–¹å¼ä¸ºæ¯ä¸ªcoreæ£€æŸ¥è‡ªå·±çš„dependenciesï¼Œå¦‚æœè®°å½•åˆ°æœ¬åœ°ï¼ŒåŒæ—¶è¿™äº›ä¾èµ–çš„ä¿¡æ¯ä¼šå‘é€ç»™å…¶å®ƒçš„coreï¼Œç„¶åé€šè¿‡èšåˆè¿™äº›ä¿¡æ¯æ¥å‘ç°å¾ªç¯çš„ä¾èµ–ã€‚è¿™äº›ä¾èµ–çš„ä¿¡æ¯ï¼Œä¼šè¢«ç¼–ç ä¸º*digest*ï¼Œå¯ä»¥ä½¿ç”¨ç±»ä¼¼ Bloom filter çš„ç»“æ„æ¥å®ç°ã€‚åœ¨è¿™æ ·çš„åŸºç¡€ä¸Šé¢ï¼Œè¿˜è¦å¤„ç†å‡ ä¸ªé—®é¢˜è¿™ç§æ–¹å¼æ‰å®é™…å¯ç”¨ã€‚å¦å¤–ä¸€ä¸ªä¼˜åŒ–æ˜¯Early Lock Release(ELR)ã€‚ä¹‹å‰çš„æ–¹å¼ä¸»è¦è®¨è®ºçš„ä¸€ä¸ªé—®é¢˜ï¼Œå°±æ˜¯å¦‚ä½•å¤„ç†åœ¨ä¸€ä¸ªXé”æå‰é‡Šæ”¾ä¹‹åï¼Œåé¢çš„Sé”è¦æ±‚ç­‰åˆ°åŠ è¿™ä¸ªXé”çš„äº‹ç‰©æäº¤äº†ï¼Œæ‰èƒ½è¿”å›ï¼Œè¿™é‡Œä½¿ç”¨è¿™æ ·çš„æ–¹å¼ï¼š

* å¯¹äºlock tableä¸­çš„æ¯ä¸ªlock queueï¼ŒåŠ ä¸Šä¸€ä¸ªtagã€‚è¿™ä¸ªtagè®°å½•æ¥æœ€è¿‘ä¿®æ”¹æ•°æ®çš„ä¸€äº›æŒä¹…åŒ–çš„ä¿¡æ¯ã€‚ä¸€ä¸ªtxnç”³è¯·lockçš„æ—¶å€™ï¼Œä¼šæ£€æŸ¥è¿™ä¸ªtagã€‚ç„¶åè®°å½•ä¸‹è§‚å¯Ÿåˆ°çš„æœ€å¤§çš„ã€‚å¦‚æœä¸€ä¸ªåªè¯»çš„äº‹ç‰©æäº¤çš„æ—¶å€™ï¼Œæ£€æŸ¥æœ€å¤§çš„tagå’Œç›®å‰çš„durable LSNï¼Œå¦‚æœä¸€ä»¶æŒä¹…åŒ–äº†ï¼Œåˆ™å¯ä»¥ç›´æ¥commitã€‚æ²¡æœ‰çš„è¯ï¼Œæƒ³è¦å”¤é†’log flusheræ¥åˆ·logã€‚å¯¹äºè¯»å†™ç±»å‹çš„txnï¼Œåˆ™åœ¨å…¶é‡Šæ”¾X lockçš„æ—¶å€™ï¼Œæ›´æ–°æœŸcommit logçš„LSNä¿¡æ¯åˆ°è¿™ä¸ªtagã€‚

  ```
  Algorithm 7: Safe SX-ELR: Commit Protocol
    Data: L: Lock table, M : Log manager 
    Input: xct: Transaction to commit
    if xct did not make any writes then //read-only xct 
      Release all locks. (S-ELR: Always safe); M.check durable(xct.max tag);
    else//read-write xct
      commitLSN = M.append-commit-log();
      // SX-ELR with the commit LSN
       foreach req âˆˆ xct.locks do //in reverse acquire-order
         queue = L.find queue (req.key); queue.release(req);
         if req.gm âˆˆ {X, XN, XS . . .} then //update tag
              queue.tag = max(queue.tag,commitLSN); 
       M.flush_until(commitLSN);
  ```

### 0x02 è¯„ä¼°

 è¿™é‡Œçš„å…·ä½“å†…å®¹å¯ä»¥å‚çœ‹[1].

## Controlled Lock Violation

### 0x10 åŸºæœ¬å†…å®¹

  è¿™ç¯‡Paperè®¨è®ºçš„å…³äºEarly Lock Releaseçš„ä¸€äº›ä¼˜åŒ–ï¼ŒåŒæ ·æ˜¯åœ¨Shore-MTä¸Šé¢åšçš„ã€‚è¿™é‡Œæå‡ºçš„æ–¹å¼ç§°ä¹‹ä¸ºControlled Lock Violationï¼Œå’ŒELRçš„æ€è·¯ç±»ä¼¼ï¼Œä½†åˆä¸æ˜¯ELRã€‚åœ¨Controlled Lock Violationçš„æ–¹å¼ä¸‹é¢ï¼Œå¦‚æœä¸€ä¸ªäº‹åŠ¡T1çœ‹åˆ°äº†ä¹‹å‰çš„ä¸€ä¸ªäº‹ç‰©T0çš„ä¸€ä¸ªä¿®æ”¹ï¼ŒT0äº‹åŠ¡ä¿®æ”¹çš„logå·²ç»æäº¤åˆ°log bufferä½†æ˜¯è¿˜æ²¡æœ‰æŒä¹…åŒ–ï¼ŒT1å¯ä»¥åœ¨T0ä»ç„¶æŒæœ‰lockçš„æƒ…å†µä¸‹è®¿é—®æ•°æ®ã€‚è¿™é‡Œç»Ÿä¸€ä¼šå¤„ç†ä¸€ä¸ªcommit dependencyçš„é—®é¢˜ï¼Œå¿…é¡»ä½¿å¾—T0åœ¨T1çš„å‰é¢commitã€‚

* commit dependencyé—®é¢˜åœ¨è¿™é‡Œçš„å¤„ç†æ˜¯å½“åšæ˜¯ä¸€ä¸ªåœ¨logä¸­æ ‡è¯†high water markçš„é—®é¢˜ã€‚å½“ä¸€ä¸ªäº‹åŠ¡T1è¿åäº†lockçš„åŸåˆ™æå‰è®¿é—®äº†T0çš„locksä¿æŠ¤çš„æ•°æ®çš„æƒ…å†µä¸‹ã€‚T0è¿™ä¸ªæ—¶å€™çš„logå¿…é¡»æ˜¯å·²ç»è®°å½•åˆ°log bufferä¸­ï¼Œ è¿™ä¸ªæ—¶å€™T0 logçš„LSNæ˜¯å¯ä»¥æŒ‡å¯¼çš„ã€‚è¿™æ ·T1å°±å¯ä»¥æŒ‡å¯¼å…¶éœ€è¦ç­‰åˆ°å“ªä¸ªLSNæŒä¹…åŒ–å®Œæˆä¹‹åï¼Œå…¶æ‰èƒ½commitã€‚å¦‚æœT1æ˜¯ä¸€ä¸ªæœ‰æ›´æ–°çš„äº‹åŠ¡ï¼ŒåŒæ ·åœ°ï¼Œå®ƒä¹Ÿä¼šå†™å…¥ä¸€äº›logã€‚è¿™ä¸ªæƒ…å†µä¸‹T1çš„LSNæ¯”L0è¦å¤§ï¼Œè¿™æ ·æ•°æ®åº“åŸæ¥çš„é€»è¾‘å°±å¯ä»¥ä¿è¯åœ¨T1å¯ä»¥commitä¹‹å‰T0å·²ç»commitäº†ã€‚å¦‚æœT1æ˜¯ä¸€ä¸ªåªè¯»çš„äº‹åŠ¡çš„è¯ï¼ŒT1éœ€è¦æœ‰ä¸€ä¸ªç­‰å¾…T0 commitçš„waitæ“ä½œã€‚å½“ç„¶å‰é¢çš„äº‹åŠ¡abortï¼Œå¯èƒ½é€ æˆéœ€è¦åé¢çš„äº‹åŠ¡ä¹Ÿabortï¼Œå³â€œabort amplificationâ€ or â€œcascading abortâ€œé—®é¢˜ã€‚Paperä¸­è¿™é‡Œæåˆ°ï¼Œå½“ä¸€ä¸ªäº‹åŠ¡çš„logå·²ç»èµ°åˆ°äº†log bufferè¿™é‡Œçš„æ—¶å€™ï¼Œä¸€èˆ¬ä¸ä¼šå‡ºç°è¿™æ ·çš„æƒ…å†µï¼Œä¸€ç§caseså°±æ˜¯system failureã€‚
* Controlled Lock Violationçœ‹ä¸Šå»å’ŒELRæ˜¯å¾ˆç±»ä¼¼çš„ï¼Œä½†æ˜¯å­˜åœ¨è¿™æ ·çš„ä¸€äº›å·®åˆ«ï¼š1. T0ä¸ä¼šæå‰é‡Šæ”¾é”ï¼Œè€Œæ˜¯ä¸€ç›´æŒæœ‰åˆ°å…¶commit/abortï¼›2. T1ä½¿ç”¨çš„æ˜¯è¿ålockè§„åˆ™çš„æ–¹å¼ï¼Œå¦å¤–T1åªèƒ½åœ¨T0çš„logå·²ç»åˆ°log bufferçš„æ—¶å€™ï¼Œæ‰èƒ½è¿åè§„åˆ™ï¼›3. Controlled Lock Violationç›¸æ¯”äºELRï¼Œå…¶ä¸éœ€è¦é¢å¤–çš„æœºåˆ¶ç­‰ã€‚

åœ¨Combined Locksæ–¹é¢ï¼Œpaperä¸­ä¹Ÿæåˆ°Controlled Lock Violationçš„ä¸€äº›ä¼˜åŠ¿ï¼Œè¿™ä¸ªCombined locksæ˜¯æ¯”å¦‚SIXè¿™æ ·åŒ…å«äº†S + IXä¸¤ç§ç±»å‹çš„ä¸€ä¸ªç»„åˆçš„lockã€‚å‡è®¾æœ‰ä¸€ä¸ªäº‹åŠ¡T0åœ¨ä¸€ä¸ªfileä¸Šé¢æŒæœ‰ä¸€ä¸ªSIXé”ï¼Œåé¢çš„äº‹åŠ¡åªæœ‰åœ¨å’Œè¿™ä¸ªé”çš„æŸä¸ªéƒ¨åˆ†æœ‰å†²çªçš„æ—¶å€™æ‰éœ€è¦æ„å»ºè¿™ä¸ªdependencyçš„ä¿¡æ¯ï¼Œæ¯”å¦‚åªå’ŒIXéƒ¨åˆ†çš„å­˜åœ¨å†²çªçš„æ—¶å€™ã€‚è€ŒELRç”±äºä½¿ç”¨æå‰ä½¿ç”¨locksçš„æ–¹å¼ï¼Œå¯èƒ½é€ æˆä¸€äº›é”ä¿¡æ¯çš„ä¸¢å¤±ï¼Œè¿™æ ·å¯èƒ½å¯¹å®é™…ä¸ŠSIXé”æ²¡æœ‰å†²çªçš„çš„æ—¶å€™ï¼Œä¹Ÿéœ€è¦è®°å½•ä¸€ä¸ªcommitä¾èµ–çš„å…³ç³»ã€‚å¦å¤–çš„ä¸€ä¸ªä¾‹å­æ˜¯range lockingï¼Œå¦‚æœä¸€ä¸ªäº‹åŠ¡T0åœ¨ä¸€ä¸ªvalue 30ä¸Šé¢åŠ ä¸Šäº†XS mode (â€œkey exclusive, gap sharedâ€)çš„é”ï¼Œå¦å¤–ä¸€ä¸ªäº‹åŠ¡T1åƒç”³è¯·ä¸€ä¸ª NX ç±»å‹çš„é”(â€œkey free, gap exclusiveâ€ â€“ N stands for no lock)ã€‚è¿™é‡Œå®é™…ä¸Šæ˜¯ä¸éœ€è¦commit dependencyçš„ã€‚å¦‚æœå†æœ‰ä¸€ä¸ªäº‹åŠ¡T2ï¼Œç”³è¯·ä¸€ä¸ªSN ç±»ä¼¼çš„é”(â€œkey shared, gap freeâ€)ï¼Œåˆ™ä¼šäº§ç”Ÿcommitä¾èµ–çš„å…³ç³»ã€‚è¿™é‡Œè°ˆåˆ°äº†å’Œå‰é¢ä¸€ç¯‡ä¸­æåˆ°çš„ELRçš„å¯¹æ¯”:

```
... With early lock release and a tag in the lock manager's hash table, it is impossible to derive these correct answers. Controlled lock violation makes the correct decision easy: As the NX lock of transaction T1 conflicts only with the read-only part of the XS lock held by transaction T0, no commit dependency is required.
```

å¦å¤–ï¼Œpaperä¸­ä¹Ÿè®¨è®ºäº†ä¸€äº›åˆ†å¸ƒå¼çš„æƒ…å†µã€‚æ¯”å¦‚å¯¹äºControlled Lock Violationæ¥è¯´ï¼Œå‰é¢çš„äº‹åŠ¡é€šçŸ¥åé¢çš„äº‹åŠ¡commitï¼Œå¯ä»¥é‡‡ç”¨register-and-report approachã€‚å³åé¢çš„äº‹åŠ¡å‘å‰é¢çš„äº‹åŠ¡ç”³è¯·ä¸€ä¸ªä¾èµ–å…³ç³»ï¼Œå‰é¢çš„äº‹åŠ¡è¦commitçš„æ—¶å€™é€šçŸ¥ï¼Œä¸å¤Ÿè¿™ä¸ªå®é™…å®ç°æƒ…å†µåº”è¯¥ä¼šå¾ˆéº»çƒ¦ã€‚

### 0x11 è¯„ä¼°

  è¿™é‡Œçš„å…·ä½“å†…å®¹å¯ä»¥å‚è€ƒ[2].

## Releasing Locks As Early As You Can: Reducing Contention of Hotspots by Violating Two-Phase Locking

### 0x20 åŸºæœ¬æ€è·¯

  è¿™ç¯‡Paperä¹Ÿæ˜¯ä¸€ç¯‡å…³äºLockæå‰é‡Šæ”¾æ¥è·å–æ›´é«˜å¹¶å‘æ€§çš„ä¸€ç¯‡paperã€‚å®ƒæå‡ºçš„æ–¹æ¡ˆç§°ä¹‹ä¸ºBambooï¼Œå…¶åŸºæœ¬æ€è·¯ä¹Ÿæ˜¯å…è®¸ä¸€äº›äº‹åŠ¡å¯ä»¥è®¿é—®Xé”çš„ä¸€äº›è§„åˆ™ã€‚å…è®¸è®¿é—®è¿™äº›locksçš„ä¸€äº›è§„åˆ™çš„è¯ï¼ŒåŒæ ·çš„è¦å¤„ç†å’Œå‰é¢ä¸¤ç¯‡ä¸€æ ·é—®é¢˜ï¼Œæ¯”å¦‚ï¼š1. Dependency Trackingï¼Œå³å‰é¢æåˆ°çš„commitä¾èµ–çš„é—®é¢˜ï¼›2. Cascading Abortsçš„é—®é¢˜ï¼Œæœ¬è´¨ä¸Šå’Œç¬¬ä¸€ä¸ªé—®é¢˜æ˜¯ç›¸åŒçš„ã€‚Bambooçš„æ–¹å¼æ˜¯åœ¨lockçš„ä½¿ç”¨è§’è‰²åœ¨ownerã€waitersä¹‹å¤–ï¼Œå¼•å…¥äº†ä¸€ä¸ªretiredçš„è§’è‰²ã€‚åŸºæœ¬æ€è·¯å¦‚ä¸‹å›¾ã€‚åœ¨ownerç›´æ¥é‡Šæ”¾çš„æ–¹å¼ä¸Šé¢ï¼Œæ·»åŠ äº†ä¸€ä¸ªretiredçš„çŠ¶æ€ï¼Œè¡¨ç¤ºå…¶æ•°æ®çš„æ›´æ–°å·²ç»å®Œæˆï¼Œä½†æ˜¯lockç›®å‰è¿˜ä¸èƒ½é‡Šæ”¾ã€‚

<img src="/assets/png/bamboo-basic.png" style="zoom:67%;" />

åœ¨è¿™æ ·çš„æ€è·¯ä¹‹ä¸Šï¼Œè®¾è®¡è¿™æ ·çš„åŸºæœ¬ç®—æ³•ã€‚Bambooä¸ºæ¯ä¸ªlockæ·»åŠ äº†ä¸€ä¸ªlistï¼Œç§°ä¹‹ä¸ºretiredã€‚åœ¨è¿™ä¸ªlistä¸Šé¢è®°å½•äº†è¿™ä¸ªlock retiredçš„äº‹åŠ¡ï¼Œå¦å¤–ä¹‹å‰å°±æœ‰ä¸€ä¸ªownerså’Œwaitersçš„listã€‚åœ¨ä¸€ä¸ªäº‹åŠ¡æ›´æ–°å®Œæˆä¸€ä¸ªæ•°æ®ä¹‹åï¼Œå…¶å¯ä»¥è®²æŒæœ‰è¿™ä¸ªlockçš„çŠ¶æ€å•Šè¾¹åƒretiredï¼Œå³ç”±ownerså˜æˆretiredã€‚è¿™ä¸ªæ—¶å€™å¦å¤–çš„äº‹åŠ¡å¯ä»¥å˜æˆè¿™ä¸ªlockçš„ownersï¼Œç„¶åè¿›è¡Œdirty readã€‚é€šè¿‡è¿™äº›listï¼Œå¯ä»¥æŒ‡å¯¼äº‹åŠ¡ä¹‹é—´çš„ä¸€ä¸ªä¾èµ–å…³ç³»ï¼Œæ¯”å¦‚åœ¨ä¸€ä¸ªäº‹åŠ¡T retiredä¹‹åï¼Œè¿™ä¸ªliståé¢çš„äº‹åŠ¡éƒ½å’Œè¿™ä¸ªäº‹åŠ¡å­˜åœ¨ä¸€ä¸ª dirty-read-induced dependenciesçš„å…³ç³»ã€‚å¦å¤–ï¼ŒBambooä¸ºæ¯ä¸ªäº‹åŠ¡æ·»åŠ äº†ä¸€ä¸ªTransaction.commit_semaphoreï¼Œé‡åˆ°ä¸€ä¸ªretiredæœ‰å†²çªçš„æƒ…å†µï¼Œåˆ™å¢åŠ è¿™ä¸ªsemaphoreçš„è®¡æ•°ï¼Œåœ¨ä¸€ä¸ªä¾èµ–çš„äº‹åŠ¡ç¦»å¼€retiredçŠ¶æ€ä¹‹åï¼Œè¿™ä¸ªsemaphoreçš„è®¡æ•°å‡å°‘ã€‚åœ¨è¿™æ ·çš„åŸºæœ¬è®¾è®¡ä¸‹è¯¾ï¼Œlockè·å–çš„é€»è¾‘å¦‚ä¸‹ã€‚è¿™ä¸ªåªæœ‰scançš„æ—¶å€™ï¼Œretiredå’Œownerséƒ½è¦è€ƒè™‘ï¼Œå¦å¤–ä¸åŒçš„ä¸€ä¸ªæ˜¯PromoteWaitersã€‚PromoteWaitersçš„ä¸»è¦æ“ä½œä¸ºscanè¿™ä¸ªlockçš„watier(æŒ‰ç…§timesampé¡ºåº)ï¼Œå¦‚æœè¿™ä¸ªwaiterå’Œå½“å‰çš„owneræ²¡æœ‰å†²çªï¼Œåˆ™å°†è¿™ä¸ªwaiterå˜æˆownerï¼Œå˜æˆownerçš„æ—¶å€™ï¼Œéœ€è¦é‡å¤„ç†å’Œretierdçš„å†²çªé—®é¢˜ã€‚

```
Function LockAcquire(txn, req_type, tuple) 
  has_conflicts = false
  for (t, type) in concat(tuple.retired, tuple.owners) do
  	if conflict(req_type, type) then
  	  has_conflicts = true
  	if has_conflicts and txn.ts < t.ts then
  	  t.set_abort()
  tuple.waiters.add(txn)
  PromoteWaiters(tuple)
  
Function PromoteWaiters(tuple)
  for t in tuple.waiters do
    if conflict(t.type, tuple.owners.type) then 
      break
    tuple.waiters.remove(t)
    tuple.owners.add(t)
    if âˆƒ(tâ€™, type) âˆˆ tuple.retired s.t. conflict(type, t.type) then
      t.commit_semaphore ++
      
# move txn from tuple.owners to tuple.retired
Function LockRetire(txn, tuple) 
  tuple.owners.remove(txn) 
  tuple.retired.add(txn)
  PromoteWaiters(tuple)
  
Function LockRelease(txn, tuple, is_abort)
  all_owners = tuple.retired âˆª tuple.owners
  if is_aborted and txn.getType(tuple) == EX then 
    abort all transactions in all_owners after txn
  remove txn from tuple.retired or tuple.owners 
  if txn was the head of tuple.retired and conflict(txn.getType(tuple), tuple.retired.head) then 
    # heads: leading non-conflicting transactions
    # Notify transactions whose dependency is clear
    for t in all_owners.heads do
      t.commit_semaphoreâˆ’âˆ’
    PromoteWaiters(tuple)
```

å¯¹äºlock retireçš„æ“ä½œï¼ŒåŸºæœ¬çš„å†…å®¹å°±æ˜¯å°†ä¸€ä¸ªäº‹åŠ¡ä»owner listç§»åŠ¨åˆ°retired listã€‚å¦å¤–åœ¨LockReleaseçš„æ“ä½œï¼š1. å¦‚æœæœ¬äº‹åŠ¡abortäº†ï¼Œè€Œä¸”æ˜¯EXç±»å‹çš„é”ï¼Œåˆ™åé¢ç›¸å…³çš„äº‹åŠ¡éƒ½éœ€è¦abortã€‚Commitæƒ…å†µä¸‹çš„releseï¼Œè¦æ›´æ–°commit_semaphoreã€‚å¦å¤–çš„ä¸€ä¸ªå†…å®¹æ˜¯ä»€ä¹ˆæ—¶å€™ä½¿ç”¨lock retireï¼Œpaperä¸­çš„æ–¹æ¡ˆæ˜¯æœ€åä¸€æ¬¡æ›´æ–°ä¸€ä¸ªtupleçš„æ—¶å€™ã€‚ä»€ä¹ˆæ—¶å€™æ˜¯æœ€åä¸€æ¬¡è®¿é—®ï¼Œå¯ä»¥é€šè¿‡programmer annotationæˆ–è€…æ˜¯program analysisçš„æ–¹å¼æ¥å®ç°ã€‚

### 0x21 Optimizations and Abort

 åœ¨åŸºæœ¬çš„æ–¹æ³•ä¹‹ä¸Šï¼Œpaperä¸­è¿˜è®¨è®ºäº†ä¸€äº›ä¼˜åŒ–çš„è®¾è®¡ï¼Œä¸»è¦æœ‰è¿™æ ·çš„å‡ ç‚¹ï¼š

* No extra latches for read operationsï¼Œå¯¹äºä¸€ä¸ªreadè¯·æ±‚ï¼Œå…¶å¯ä»¥ç›´æ¥åœ¨lock acquireçš„æ—¶å€™å°±retireã€‚å¦‚æœåé¢ä¸ä¼šå†™å…¥è¯»å–äº†çš„tupleï¼Œåˆ™å¯ä»¥å°†è¯»å–äº†çš„ä¸€éƒ¨åˆ†çš„æ•°æ®ä¿å­˜åˆ°ä¸€ä¸ªæš‚å­˜åŒºä¸­ã€‚

* No retire when there is no benefitï¼Œåœ¨ä¸€äº›æƒ…å†µä¸‹retireçš„æƒ…å†µæ²¡æœ‰æ”¶ç›Šï¼Œè¿™é‡Œæ˜¯é€šè¿‡åœ¨ç­‰å¾…commit_semaphoreä¸Šé¢çš„æ—¶é—´æ¥åˆ¤æ–­ï¼Œ

  ```
   We use a simple heuristic where writes in the last ğ›¿ (0 â‰¤ ğ›¿ â‰¤ 1) fraction of accesses are not retired. ... . However, if a transaction turns out to spend significant time (i.e., longer than ğ›¿ of the total execution time) waiting on the commit_semaphore, we will retire those write operations at the end of a transaction.
  ```

* Eliminate aborts due to read-after-write conflictsï¼Œåœ¨å‰é¢çš„æ–¹æ³•ä¸­ï¼Œä¸€ä¸ªäº‹åŠ¡ç”³è¯·ä¸€ä¸ªSé”çš„æ—¶å€™ï¼Œä¼šabortå·²ç»åœ¨è¿™ä¸ªlockä¸Šé¢çš„æ›´ä½ä¼˜å…ˆçº§çš„å†™æ“ä½œçš„äº‹åŠ¡ã€‚è¿™é‡Œå› ä¸ºBambooä¿å­˜äº†ä¸€ä¸ªlocal copyï¼Œè¿™æ ·å°±å¯ä»¥è®©ä¸€ä¸ªtupleæœ‰å¤šä¸ªçš„æ²¡æœ‰æäº¤çš„æ›´æ–°ï¼Œå®é™…åº”ç”¨çš„æ—¶å€™è¿˜éœ€è¦è§£å†³è¯»å–é‚£ä¸ªç‰ˆæœ¬çš„é—®é¢˜ï¼š

  ```
  The optimization naturally fits Bamboo as it allows for read-modify- write over dirty data and multiple uncommitted updates can exist on a tuple. However, the idea cannot be easily applied to existing 2PL as reading uncommitted data is not allowed hence there exists only one copy of the data. 
  ```

* Assign timestamps to a transaction on its first conflictï¼Œå¦å¤–ä¸€ä¸ªtimestampæ€ä¹ˆé€‰æ‹©çš„é—®é¢˜ã€‚

### 0x22 è¯„ä¼°

 è¿™é‡Œçš„å…·ä½“å†…å®¹å¯ä»¥å‚çœ‹[3].

## å‚è€ƒ

1. Efficient Locking Techniques for Databases on Modern Hardware, ADMS '12.
2. Controlled Lock Violation, SIGMOD '13.
3. Releasing Locks As Early As You Can: Reducing Contention of Hotspots by Violating Two-Phase Locking, arXiv.

